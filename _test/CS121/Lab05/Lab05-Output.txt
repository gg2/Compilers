Script started on Thu 19 Feb 2015 04:11:42 PM PST
[?1034hbash-4.1$ make testStack
g++    -c -o testStack.o testStack.cpp
g++    -c -o stack.o stack.cpp
g++    -c -o link.o link.cpp
g++ -o testStack testStack.o stack.o link.o
bash-4.1$ ls
link.cpp  link.o    MakeStack.txt  stack.h  testStack	   testStack.o
link.h	  Makefile  stack.cpp	   stack.o  testStack.cpp
bash-4.1$ echo "Modified link.h and uploaded"
Modified link.h and uploaded
bash-4.1$ make testStack
g++    -c -o stack.o stack.cpp
g++    -c -o link.o link.cpp
g++ -o testStack testStack.o stack.o link.o
bash-4.1$ make testStack
make: `testStack' is up to date.
bash-4.1$ echo "Modified link.h and uploaded again"
Modified link.h and uploaded again
bash-4.1$ make testStack
g++    -c -o stack.o stack.cpp
g++    -c -o link.o link.cpp
g++ -o testStack testStack.o stack.o link.o
bash-4.1$ make testStack
make: `testStack' is up to date.

[
	1) make compiles the main program file, testStack.cpp, 
	and presumedly grabs stack.h and link.h as well, because 
	it is indicated that testStack.cpp is dependent on them.
	
	It is surprising that make grabs stack.cpp and link.cpp, too, 
	because they are not utilized in the file.
	( $(SRCS) is assigned those filenames, but that variable 
	is never referenced.) So make must implicitly assume that .h files have 
	a corresponding .cpp.
	
	2) The last argument to make seems to be the rule to run. 
	I assume this because the "clean" rule is accessed in a similar fashion;
	and if "testStack" is left off, make goes through the whole routine anyway.
	"All" points make to testStack anyway, 
	so "make" and "make testStack" seem the same, in this circumstance.
]

bash-4.1$ ls
link.cpp  link.o    MakeStack.txt  stack.h  testStack	   testStack.o
link.h	  Makefile  stack.cpp	   stack.o  testStack.cpp
bash-4.1$ make clean
rm -f testStack 
rm *.o
bash-4.1$ ls
link.cpp  link.h  Makefile  MakeStack.txt  stack.cpp  stack.h  testStack.cpp
bash-4.1$ exit
exit

Script done on Thu 19 Feb 2015 04:17:49 PM PST

[
	3) "make clean" invokes the clean rule in the makefile.
	The clean rule is assigned the commands "rm *.o" and "$(RM) testStack": 
	the former deletes all files ending in ".o" (all the object files created by make)
	and the latter presumedly accesses a default variable that defines 
	the delete command dependent on the current environment, 
	which then deletes the compiled output.
	So "clean" removes the results of the make command, entirely in this instance.
]

* * * * * * * * * * * * * * * * * * * * * * * * *

Script started on Thu 19 Feb 2015 04:19:37 PM PST
[?1034hbash-4.1$ make testStack
g++    -c -o testStack.o testStack.cpp
g++    -c -o stack.o stack.cpp
g++    -c -o link.o link.cpp
g++ -o testStack testStack.o stack.o link.o
bash-4.1$ ./testStack
Pushing integers onto iStack
0 1 2 3 4 
Contents of iStack
4
3
2
1
0

Popping integers from iStack
4 3 2 1 0 
The stack is empty
bash-4.1$ exit
exit

Script done on Thu 19 Feb 2015 04:19:57 PM PST

* * * * * * * * * * * * * * * * * * * * * * * * *

Script started on Thu 19 Feb 2015 06:17:16 PM PST
[?1034hbash-4.1$ pwd
/home/gibl3465/CS121/Lab05/Queue
bash-4.1$ ls
listQ.cpp  Makefile	 MakeQueue.txt	queueL.h
listQ.h    Makefile.txt  queueL.cpp	testQueue.cpp
bash-4.1$ make -f MakeQueue.txt testQueue
g++    -c -o listQ.o listQ.cpp
g++    -c -o queueL.o queueL.cpp
g++    -c -o testQueue.o testQueue.cpp
g++ -o testQueue testQueue.o queueL.o listQ.o
bash-4.1$ ./testQueue
Initial contents of q1:
3
5
Contents of q1 after adding:
3
5
1

Deleting two items from queue:
Contents of q1 after deleting one item:
5
1
Contents of q1 after deleting one item:
1
bash-4.1$ ls
listQ.cpp  listQ.o   Makefile.txt   queueL.cpp	queueL.o   testQueue.cpp
listQ.h    Makefile  MakeQueue.txt  queueL.h	testQueue  testQueue.o
bash-4.1$ exit
exit

Script done on Thu 19 Feb 2015 06:18:05 PM PST
