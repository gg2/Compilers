CS 121, Lab 14
Journal

20150503
20:50-11:59 > Getting and reading through lab requirements. Writing out general program requirements. Gathering sorting functions. Distractedly creating data generation routines. Wondering if there is a decent way to pass the test parameters to a subroutine (aka function), esp. using function pointers. Seems pointless, if for no other reason than because I have to pass in the function names anyway to call the right function.

20150504
11:30-12:20 > Compiling to see whether basic layout and retrieved sort functions have issues. Sorting out compile-time issues. Sorting out issues handling array. Functionizing whole handling routine.
21:15-22:27 > Making array generation work. Trying out Selection Sort, to make sure it works.

20150505
21:30-22:45 > Implementing other sorting methods, Quicksort and Mergesort. Modifying the main routine to accept a function pointer; and modifying the sorting functions to all have same signature. Watching Selection Sort print and run, lots, for the 10000-size array.

20150506
11:15-12:22 > Looking at what actually needs to be recorded. Fleshed out a system for filling out an array of analysis data: per array size, data arrangement, sort function used, and then each operation tracked.

20150507
13:30-14:09 > Compile and test what I last did. Work out issues (can't use for loops outside of functions apparently). Improve display. 
14:09-15:40 > Actually insert counts now wherever seems appropriate. Breaking down what to count into 4 categories. We'll see if it works. Have to remember to get rid of int and other declaration pieces when copy/pasting declarations to initialize and utilize variables elsewhere!!! Wasting time troubleshooting stupid problems!!! OK. Results. Reenabling 10000-size arrays.

- - - - - - - - - - -

Results:

When sorted ascending, Selection Sort pretty much does no work and seems (predictably) the fastest.
But that is offset by lists sorted descending, where the amount of work Selection Sort does grows tremendously.

Quicksort usually seems to be about on par with Selection Sort for number of comparisons, and the number of swaps and assignments is about double Selection Sort generally.

For a given list size, Mergesort is pretty constant no matter how the list is sorted initially; and Mergesort grows less slowly than the other 2 sorts.

If expecting larger lists, Mergesort is definitely the winner.

- - - - - - - - - - -

Program Requirements

1) Functions to generate the data sets: random unsorted, sorted ascending, sorted descending; 100, 1000, 10000
2) Sorting functions: selection, mergesort, quicksort.
3) Means to analyse performance: # comparisons; # swaps; 
4) Display results of analysis.

Procedure: 100 unsorted x 3 sorts, display results; 100 ascending x 3 sorts, display results; 100 descending x 3 sorts, display results; 1000 unsorted, 1000 ascending, 1000 descending; 10000, etc.
